const axios = require('axios');
const mensagens = require('./mensagens');
const API = require('./api');
const { getFollowUpSystem } = require('./bot');

/**
 * Envia aviso de op√ß√£o inv√°lida no menu principal
 */
async function enviarAvisoMenuPrincipal(sock, jid) {
    try {
        return await sock.sendMessage(jid, { text: mensagens.avisoInvalido });
    } catch (error) {
        console.error('Erro ao enviar aviso do menu principal:', error);
    }
}

/**
 * Envia o menu principal para o usu√°rio
 */
async function enviarMenuPrincipal(sock, jid) {
    try {
        return await sock.sendMessage(jid, {
            text: mensagens.menuPrincipal
        });
    } catch (error) {
        console.error('Erro ao enviar menu principal:', error);
    }
}

/**
 * Envia o submenu de teste - REMOVIDO REGISTRO DUPLICADO
 */
async function enviarSubmenuTeste(sock, jid, aparelho) {
    // ‚ùå REMOVIDO: followUpSystem.registrarTeste() - estava duplicando!
    
    try {
        await sock.sendMessage(jid, { text: mensagens.submenuTeste });
        return { fase: 'submenu_teste', aparelho };
    } catch (error) {
        console.error('Erro ao enviar submenu teste:', error);
    }
}

/**
 * Envia mensagem de erro padr√£o
 */
async function enviarMensagemErro(sock, jid) {
    try {
        return await sock.sendMessage(jid, { 
            text: '‚ùå Op√ß√£o inv√°lida. Digite "Menu" para voltar ao in√≠cio.' 
        });
    } catch (error) {
        console.error('Erro ao enviar mensagem de erro:', error);
    }
}

/**
 * Handler do menu principal - CORRIGIDO LIMITE DE TESTE
 */
async function handleMenuPrincipal(sock, jid, comando, atendimentos) {
    // Inicializa o objeto do cliente se n√£o existir
    if (!atendimentos[jid]) {
        atendimentos[jid] = {
            ativo: true,
            fase: 'menu_principal',
            aparelho: null,
            ultimaInteracao: new Date(),
            ultimoTeste: null
        };
    }

    switch (comando) {
        case '1':
            // ‚úÖ CORRIGIDO: Verifica limite ANTES de prosseguir
            const hoje = new Date();
            const ultimoTeste = atendimentos[jid].ultimoTeste;
            const diffDias = ultimoTeste ? Math.floor((hoje - new Date(ultimoTeste)) / (1000 * 60 * 60 * 24)) : null;
            
            if (ultimoTeste && diffDias < 30) {
                await sock.sendMessage(jid, {
                    text: `‚ùå Voc√™ j√° gerou um teste nos √∫ltimos ${30 - diffDias} dias.\nüí° Que tal assinar um plano?\n\nüì¶ **MENSAL**: R$ 20/m√™s\nüì¶ **TRIMESTRAL**: R$ 50 (3 meses)\nüì¶ **ANUAL**: R$ 150 (12 meses) üî•\n\nüí¨ Digite "Menu" para outras op√ß√µes.`
                });
                return; // N√£o prossegue se j√° testou
            }

            // ‚úÖ CORRIGIDO: Marca que tentou teste ANTES da API (evita spam)
            atendimentos[jid].ultimoTeste = new Date();
            atendimentos[jid].fase = 'submenu_aparelho';
            return await sock.sendMessage(jid, { text: mensagens.submenuAparelho });

        case '2':
            atendimentos[jid].ativo = false; // desativa o bot pra esse usu√°rio
            return await sock.sendMessage(jid, { 
                text: 'üí¨ **NOSSOS PLANOS SD PLAY** üî•\n\nüì¶ **MENSAL**: R$ 20/m√™s\n‚Ä¢ Todos os canais HD/4K\n‚Ä¢ Filmes e s√©ries atualizados\n‚Ä¢ Suporte t√©cnico 24h\n\nüì¶ **TRIMESTRAL**: R$ 50 (3 meses)\n‚Ä¢ Economia de R$ 10\n‚Ä¢ Todos os benef√≠cios\n\nüì¶ **ANUAL**: R$ 150 (12 meses)\n‚Ä¢ Economia de R$ 90 ü§ë\n‚Ä¢ Melhor custo-benef√≠cio\n‚Ä¢ Prioridade no suporte\n\nüí° Digite "Menu" para outras op√ß√µes ou fale com atendente!' 
            });

        case '3':
            atendimentos[jid].ativo = false;
            return await sock.sendMessage(jid, { 
                text: 'üë®‚Äçüíª Voc√™ ser√° atendido em breve.\n‚è±Ô∏è Tempo m√©dio de resposta: 5 minutos\n\nüí° Digite "Menu" para voltar ao in√≠cio.' 
            });

        default:
            await sock.sendMessage(jid, { text: mensagens.avisoInvalido });
            return;
    }
}

/**
 * Handler do submenu de aparelhos
 */
async function handleSubmenuAparelho(sock, jid, comando, atendimentos) {
    switch (comando) {
        case '1': // Smart TV
            atendimentos[jid].fase = 'submenu_smarttv';
            return await sock.sendMessage(jid, { text: mensagens.submenuSmartTV });
        case '2': // TV Box
            const tvboxResult = await enviarSubmenuTeste(sock, jid, 'TVBOX');
            Object.assign(atendimentos[jid], tvboxResult);
            return;
        case '3': // Celular
            atendimentos[jid].fase = 'submenu_celular';
            return await sock.sendMessage(jid, { text: mensagens.submenuCelular });
        default:
            return await enviarMensagemErro(sock, jid);
    }
}

/**
 * Handler do submenu Smart TV
 */
async function handleSubmenuSmartTV(sock, jid, comando, atendimentos) {
    if (comando === '1') {
        const smarttvResult = await enviarSubmenuTeste(sock, jid, 'SMARTTV');
        Object.assign(atendimentos[jid], smarttvResult);
        return;
    } else if (comando === '2') {
        atendimentos[jid].ativo = false;
        return await sock.sendMessage(jid, { 
            text: 'üë®‚Äçüíª Um atendente especializado em Smart TVs ir√° ajud√°-lo.\n‚è±Ô∏è Tempo m√©dio: 5 minutos\n\nüí° Digite "Menu" para voltar ao in√≠cio.' 
        });
    }
    return await enviarMensagemErro(sock, jid);
}

/**
 * Handler do submenu celular
 */
async function handleSubmenuCelular(sock, jid, comando, atendimentos) {
    if (comando === '1') { // Android
        const androidResult = await enviarSubmenuTeste(sock, jid, 'ANDROID');
        Object.assign(atendimentos[jid], androidResult);
        return;
    } else if (comando === '2') { // iOS
        const iosResult = await enviarSubmenuTeste(sock, jid, 'IOS');
        Object.assign(atendimentos[jid], iosResult);
        return;
    }
    return await enviarMensagemErro(sock, jid);
}

/**
 * Handler do submenu de teste - TOTALMENTE CORRIGIDO
 */
async function handleSubmenuTeste(sock, jid, comando, atendimentos) {
    const tipo = comando === '1' ? 'COM_ADULTO' : comando === '2' ? 'SEM_ADULTO' : null;
    if (!tipo) return await enviarMensagemErro(sock, jid);

    const aparelho = atendimentos[jid].aparelho;
    const apiURL = aparelho === 'SMARTTV' ? API.SMARTTV[tipo] : API.ANDROID_TVBOX[tipo];

    // ‚úÖ CORRIGIDO: Mapeia aparelho ANTES de usar
    let aparelhoCorreto;
    if (aparelho === 'TVBOX') aparelhoCorreto = 'ANDROID';
    else if (aparelho === 'ANDROID') aparelhoCorreto = 'ANDROID'; 
    else if (aparelho === 'IOS') aparelhoCorreto = 'IOS';
    else if (aparelho === 'SMARTTV') aparelhoCorreto = 'SMARTTV';
    else aparelhoCorreto = 'ANDROID'; // fallback

    // Mostra mensagem de carregamento
    await sock.sendMessage(jid, { text: '‚è≥ Gerando seu teste... Aguarde alguns segundos...' });

    let tentativa = 0;
    let sucesso = false;

    while(tentativa < 3 && !sucesso) {
        try {
            tentativa++;
            console.log(`üîÑ Tentativa ${tentativa} para ${jid} - ${aparelhoCorreto} - ${tipo}`);

            const response = await axios.get(apiURL, {
                timeout: 15000 // 15 segundos timeout
            });

            if (response.status === 200) {
                // ‚úÖ REGISTRA FOLLOW-UP APENAS 1 VEZ E AP√ìS SUCESSO
                const followUpSystem = getFollowUpSystem();
                if (followUpSystem) {
                    followUpSystem.registrarTeste(jid, tipo, aparelhoCorreto);
                    console.log(`üìù Follow-up registrado para ${jid}`);
                }

                // Define mensagem do app baseado no aparelho
                let mensagemApp = '';
                switch(aparelhoCorreto) {
                    case 'SMARTTV':
                        mensagemApp = mensagens.appSmartTV;
                        break;
                    case 'ANDROID':
                        mensagemApp = mensagens.appAndroid;
                        break;
                    case 'IOS':
                        mensagemApp = mensagens.appIOS;
                        break;
                    default:
                        mensagemApp = mensagens.appAndroid;
                }

                // Envia resposta da API + instru√ß√µes do app
                const mensagemCompleta = `${response.data}\n\n${mensagemApp}\n\nüí° Digite "Menu" para outras op√ß√µes.`;
                await sock.sendMessage(jid, { text: mensagemCompleta });

                // Mensagem adicional ap√≥s 3 segundos
                setTimeout(async () => {
                    const duracao = (aparelhoCorreto === 'SMARTTV' || aparelhoCorreto === 'IOS') ? '6 horas' : '4 horas';
                    await sock.sendMessage(jid, { 
                        text: `üéâ **Teste enviado com sucesso!**\n\nüí° Aproveite as ${duracao} de acesso completo!\nüì∫ Teste todos os canais e qualidade HD/4K!`
                    });
                }, 3000);

                // Volta ao menu principal
                atendimentos[jid].fase = 'menu_principal';
                atendimentos[jid].aparelho = null;
                sucesso = true;

                console.log(`‚úÖ Teste enviado com sucesso para ${jid} - ${aparelhoCorreto}`);
            }
            
        } catch (error) {
            console.error(`‚ùå Tentativa ${tentativa} falhou para ${jid}:`, error.message);
            
            if(tentativa === 3) {
                // ‚úÖ CORRIGIDO: Se falhar, volta o ultimoTeste para null (permite nova tentativa)
                atendimentos[jid].ultimoTeste = null;
                
                // Volta ao menu principal
                atendimentos[jid].fase = 'menu_principal';
                atendimentos[jid].aparelho = null;
                
                await sock.sendMessage(jid, { 
                    text: '‚ùå **Erro tempor√°rio no sistema**\n\nNossos servidores est√£o sobrecarregados. Tente novamente em alguns minutos.\n\nüí° Digite "Menu" para tentar novamente.' 
                });
            } else {
                // Aguarda antes da pr√≥xima tentativa
                await new Promise(resolve => setTimeout(resolve, 2000));
            }
        }
    }
}

module.exports = {
    enviarMenuPrincipal,
    enviarSubmenuTeste,
    enviarMensagemErro,
    handleMenuPrincipal,
    handleSubmenuAparelho,
    handleSubmenuSmartTV,
    handleSubmenuCelular,
    handleSubmenuTeste
};
